import type { PlaywrightPluginConfig, OperationMeta } from '../types';
import { resolveConfig } from './config';
import { adaptOpenApiTsOperation } from '../core/openapi-ts-adapter';
import { generateFixtures, generateFixtureTypes } from '../generators/playwright-fixture-generator';
import { generateRouteHandlers } from '../generators/playwright-route-generator';
import { generateMockBuilders } from '../generators/playwright-builder-generator';
import { generateMswHandlers } from '../generators/msw-handler-generator';

interface SchemaEvent {
  name: string;
  schema: Record<string, unknown>;
}

// Operation event from openapi-ts
interface OperationEvent {
  operation: any; // Using any as the structure is complex and internal to openapi-ts
}

interface PluginFile {
  add: (content: string) => void;
}

interface PluginContext {
  name: string;
  output: string;
  config: PlaywrightPluginConfig;
  createFile: (options: { id: string; path: string }) => PluginFile;
  forEach: (
    type: 'schema' | 'operation',
    callback: (event: SchemaEvent | OperationEvent) => void
  ) => void;
}

export type PlaywrightHandler = (context: { plugin: PluginContext }) => void;

function generateImports(): string {
  return `// Generated by hey-api-playwright
// Do not edit manually

import type { Page, Request } from '@playwright/test';
import * as types from './types.gen';
import * as builders from './builders.gen';

`;
}

function getBuilderImports(operations: OperationMeta[]): Set<string> {
  const imports = new Set<string>();

  for (const operation of operations) {
    for (const response of operation.responses) {
      if (response.schemaName) {
        imports.add(`${response.schemaName}Builder`);
      }
    }
  }

  return imports;
}

export const handler: PlaywrightHandler = (context) => {
  const { plugin } = context;
  const config = resolveConfig(plugin.config);

  const rawSchemas: Record<string, Record<string, unknown>> = {};

  plugin.forEach('schema', (event) => {
    const schemaEvent = event as SchemaEvent;
    rawSchemas[schemaEvent.name] = schemaEvent.schema;
  });

  const operations: OperationMeta[] = [];

  // Use 'any' cast to support 'operation' event type if strict typing complains
  (plugin as any).forEach('operation', (event: OperationEvent) => {
    if (event.operation) {
      const op = adaptOpenApiTsOperation(event.operation, rawSchemas);
      operations.push(op);
    }
  });

  operations.sort((a, b) => a.operationId.localeCompare(b.operationId));

  const file = plugin.createFile({ id: plugin.name, path: config.output });

  let output = generateImports();
  if (config.generateMsw) {
    output = `import { http, HttpResponse } from 'msw';\n` + output;
  }

  const builderImports = getBuilderImports(operations);
  if (builderImports.size > 0) {
    output = output.replace(
      "import * as builders from './builders.gen';",
      `import { ${Array.from(builderImports).join(', ')} } from './builders.gen';`
    );
  }

  output += generateFixtureTypes(operations);
  output += generateFixtures(operations, {
    generateErrorMocks: config.generateErrorMocks,
    mockStrategy: config.mockStrategy,
  });

  output += generateRouteHandlers(operations, {
    baseUrlPattern: config.baseUrlPattern,
    generateErrorMocks: config.generateErrorMocks,
  });

  if (config.generateBuilders) {
    output += generateMockBuilders(operations, {
      baseUrlPattern: config.baseUrlPattern,
      generateErrorMocks: config.generateErrorMocks,
    });
  }

  if (config.generateMsw) {
    output += generateMswHandlers(operations, {
      baseUrlPattern: config.baseUrlPattern,
    });
  }

  file.add(output);
};
