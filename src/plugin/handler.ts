import type { PlaywrightPluginConfig, OperationMeta } from '../types';
import { resolveConfig } from './config';
import { collectOperations } from '../core/operation-collector';
import { generateFixtures, generateFixtureTypes } from '../generators/playwright-fixture-generator';
import { generateRouteHandlers } from '../generators/playwright-route-generator';
import { generateMockBuilders } from '../generators/playwright-builder-generator';

interface SchemaEvent {
  name: string;
  schema: Record<string, unknown>;
}

interface PathEvent {
  path: string;
  item: Record<string, unknown>;
}

interface PluginFile {
  add: (content: string) => void;
}

interface PluginContext {
  name: string;
  output: string;
  config: PlaywrightPluginConfig;
  createFile: (options: { id: string; path: string }) => PluginFile;
  forEach: (type: 'schema' | 'path', callback: (event: SchemaEvent | PathEvent) => void) => void;
}

export type PlaywrightHandler = (context: { plugin: PluginContext }) => void;

function generateImports(): string {
  return `// Generated by hey-api-playwright
// Do not edit manually

import type { Page } from '@playwright/test';
import * as types from './types.gen';
import * as builders from './builders.gen';

`;
}

function getBuilderImports(operations: OperationMeta[]): Set<string> {
  const imports = new Set<string>();

  for (const operation of operations) {
    for (const response of operation.responses) {
      if (response.schemaName) {
        imports.add(`${response.schemaName}Builder`);
      }
    }
  }

  return imports;
}

export const handler: PlaywrightHandler = ({ plugin }) => {
  const config = resolveConfig(plugin.config);

  const rawSchemas: Record<string, Record<string, unknown>> = {};
  const rawPaths: Record<string, Record<string, unknown>> = {};

  plugin.forEach('schema', (event) => {
    const schemaEvent = event as SchemaEvent;
    rawSchemas[schemaEvent.name] = schemaEvent.schema;
  });

  plugin.forEach('path', (event) => {
    const pathEvent = event as PathEvent;
    rawPaths[pathEvent.path] = pathEvent.item;
  });

  const operations = collectOperations(rawPaths, rawSchemas);
  const file = plugin.createFile({ id: plugin.name, path: config.output });

  let output = generateImports();

  const builderImports = getBuilderImports(operations);
  if (builderImports.size > 0) {
    output = output.replace(
      "import * as builders from './builders.gen';",
      `const { ${Array.from(builderImports).join(', ')} } = builders;`
    );
  }

  output += generateFixtureTypes(operations);
  output += generateFixtures(operations, {
    generateErrorMocks: config.generateErrorMocks,
    mockStrategy: config.mockStrategy,
  });

  output += generateRouteHandlers(operations, {
    baseUrlPattern: config.baseUrlPattern,
    generateErrorMocks: config.generateErrorMocks,
  });

  if (config.generateBuilders) {
    output += generateMockBuilders(operations, {
      baseUrlPattern: config.baseUrlPattern,
      generateErrorMocks: config.generateErrorMocks,
    });
  }

  file.add(output);
};
